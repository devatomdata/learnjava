[
  {
    "title": "Introduction",
    "data":"Java is a popular programming language, created in 1995.\n\nIt is owned by Oracle, and more than 3 billion devices run Java.\n\nIt is used for:\n\nMobile applications (specially Android apps)\nDesktop applications\nWeb applications\nWeb servers and application servers\nGames\nDatabase connection\nAnd much, much more!",
    "subtype1" : "Why Use Java?",
    "data1": "Java works on different platforms (Windows, Mac, Linux, Raspberry Pi, etc.)\nIt is one of the most popular programming language in the world\nIt is easy to learn and simple to use\nIt is open-source and free\nIt is secure, fast and powerful\nIt has a huge community support (tens of millions of developers)\nJava is an object oriented language which gives a clear structure to programs and allows code to be reused, lowering development costs\nAs Java is close to C++ and C#, it makes it easy for programmers to switch to Java or vice versa\n",
    "subtype2": "Installing",
    "data2": "Some PCs might have Java already installed.\n\nTo check if you have Java installed on a Windows PC, search in the start bar for Java or type the following in Command Prompt (cmd.exe):\n\nC:\\Users\\Your Name>java -version\nIf Java is installed, you will see something like this (depending on version):\n\njava version \"11.0.1\" 2018-10-16 LTS\nJava(TM) SE Runtime Environment 18.9 (build 11.0.1+13-LTS)\nJava HotSpot(TM) 64-Bit Server VM 18.9 (build 11.0.1+13-LTS, mixed mode)\nIf you do not have Java installed on your computer, you can download it for free from oracle.com.\n\nNote: In this tutorial, we will write Java code in a text editor. However, it is possible to write Java in an Integrated Development Environment, such as IntelliJ IDEA, Netbeans or Eclipse, which are particularly useful when managing larger collections of Java files.\n\n",
    "subtype3": "Setup for Windows",
    "data3": "To install Java on Windows:\n\n1. Go to \"System Properties\" (Can be found on Control Panel > System and Security > System > Advanced System Settings)\n2. Click on the \"Environment variables\" button under the \"Advanced\" tab\n3. Then, select the \"Path\" variable in System variables and click on the \"Edit\" button\n4. Click on the \"New\" button and add the path where Java is installed, followed by \\bin. By default, Java is installed in C:\\Program Files\\Java\\jdk-11.0.1 (If nothing else was specified when you installed it). In that case, You will have to add a new path with: C:\\Program Files\\Java\\jdk-11.0.1\\bin\nThen, click \"OK\", and save the settings\n5. At last, open Command Prompt (cmd.exe) and type java -version to see if Java is running on your machine",
    "subtype4": "",
    "data4": ""
  },
  {
    "title": "Java Quickstart",
    "data": "",
    "subtype1": "Hello World",
    "data1": "Java is an object oriented language (OOP). Java objects are part of so-called \"Java classes\".\n\nLet's go over the Hello world program, which simply prints \"Hello, World!\" to the screen.\n\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(\"This will be printed\");\n    }\n}\nThe first line defines a class called Main.\n\npublic class Main {\nIn Java, every line of code that can actually run needs to be inside a class. This line declares a class named Main, which is public, that means that any other class can access it. This is not important for now, so don't worry. For now, we'll just write our code in a class called Main, and talk about objects later on.\n\nNotice that when we declare a public class, we must declare it inside a file with the same name (Main.java), otherwise we'll get an error when compiling.\n\nWhen running the examples on the site, we will not use the public keyword, since we write all our code in one file.\n\nThe next line is:\n\npublic static void main(String[] args) {\nThis is the entry point of our Java program. the main method has to have this exact signature in order to be able to run our program.\n\npublic again means that anyone can access it.\nstatic means that you can run this method without creating an instance of Main.\nvoid means that this method doesn't return any value.\nmain is the name of the method.\nThe arguments we get inside the method are the arguments that we will get when running the program with parameters. It's an array of strings. We will use it in our next lesson, so don't worry if you don't understand it all now.\n\nSystem.out.println(\"This will be printed\");\nSystem is a pre-defined class that Java provides us and it holds some useful methods and variables.\nout is a static variable within System that represents the output of your program (stdout).\nprintln is a method of out that can be used to print a line.",
    "subtype2": "Exercise",
    "data2": "Print \"Hello, World!\" to the console.",
    "subtype3": "Solution",
    "data3": "public class Main {\n\n    public static void main(String[] args) {\n\n        System.out.println(\"Hello, World!\");\n\n    }\n\n}",
    "subtype4": "",
    "data4": ""
  },
  {
    "title": "Variables and Types",
    "data": "Although Java is object oriented, not all types are objects. It is built on top of basic variable types called primitives.\n\nHere is a list of all primitives in Java:\n\nbyte (number, 1 byte)\nshort (number, 2 bytes)\nint (number, 4 bytes)\nlong (number, 8 bytes)\nfloat (float number, 4 bytes)\ndouble (float number, 8 bytes)\nchar (a character, 2 bytes)\nboolean (true or false, 1 byte)\nJava is a strong typed language, which means variables need to be defined before we use them.",
    "subtype1": "Numbers",
    "data1":"To declare and assign a number use the following syntax:\n\nint myNumber;\nmyNumber = 5;\nOr you can combine them:\n\nint myNumber = 5;\nTo define a double floating point number, use the following syntax:\n\ndouble d = 4.5;\nd = 3.0;\nIf you want to use float, you will have to cast:\n\nfloat f = (float) 4.5;\nOr, You can use this:\n\nfloat f = 4.5f; // (f is a shorter way of casting float)",
    "subtype2": "Characters and Strings",
    "data2": "In Java, a character is it's own type and it's not simply a number, so it's not common to put an ascii value in it, there is a special syntax for chars:\n\nchar c = 'g';\nString is not a primitive. It's a real type, but Java has special treatment for String.\n\nHere are some ways to use a string:\n\n// Create a string with a constructor\nString s1 = new String(\"Who let the dogs out?\");        // String object stored in heap memory\n// Just using \"\" creates a string, so no need to write it the previous way.\nString s2 = \"Who who who who!\";                         // String literal stored in String pool\n// Java defined the operator + on strings to concatenate:\nString s3 = s1 + s2;\nString is the only class where operator overloading is supported in java rest There is no operator overloading in Java! We can concat two strings using + operator. The operator + is only defined for strings, you will never see it with other objects, only primitives.\n\nYou can also concat string to primitives:\n\nint num = 5;\nString s = \"I have \" + num + \" cookies\"; //Be sure not to use \"\" with primitives.",
    "subtype3": "boolean",
    "data3": "Every comparison operator in java will return the type boolean. Unlike other languages, it only accepts two special values: true or false.\n\nboolean b = false;\nb = true;\n\nboolean toBe = false;\nb = toBe || !toBe;\nif (b) {\n    System.out.println(toBe);\n}\n\nint children = 0;\nb = children; // Will not work\nif (children) { // Will not work\n    // Will not work\n}\n\nint a;\nboolean b = true; \nboolean c = false; \na = b + c;            //The following line will give an error\nSystem.out.println(a);",
    "subtype4": "Exercise and Solution",
    "data4": "Exercise :\n\nCreate all of the primitives (except long and double) with different values. Concatenate them into a string and print it to the screen so it will print: H3110 w0r1d 2.0 true\n\nSolution:\n\npublic class Main {\n    public static void main(String[] args) {\n        byte zero = 0;\n        short a = 3;\n        int b = 1;\n        char d = ' ';\n        float e = 2.0f;\n        boolean f = true;\n        String output = \"H\" + a + b + b + zero + d + \"w\" + zero + \"r\" + b + \"d\" + d + e + d + f;\n        System.out.println(output);\n    }\n}"
  },
  {
    "title": "Conditionals",
    "data": "Java uses boolean variables to evaluate conditions. The boolean values true and false are returned when an expression is compared or evaluated. For example:\n\nint a = 4;\nboolean b = a == 4;\n\nif (b) {\n    System.out.println(\"It's true!\");\n}\nOf course we don't normally assign a conditional expression to a boolean. Normally, we just use the short version:\n\nint a = 4;\n\nif (a == 4) {\n    System.out.println(\"Ohhh! So a is 4!\");\n}",
    "subtype1": "Boolean operators",
    "data1":"There aren't that many operators to use in conditional statements and most of them are pretty straight forward:\n\nint a = 4;\nint b = 5;\nboolean result;\nresult = a < b; // true\nresult = a > b; // false\nresult = a <= 4; // a smaller or equal to 4 - true\nresult = b >= 6; // b bigger or equal to 6 - false\nresult = a == b; // a equal to b - false\nresult = a != b; // a is not equal to b - true\nresult = a > b || a < b; // Logical or - true\nresult = 3 < a && a < 6; // Logical and - true\nresult = !result; // Logical not - false",
    "subtype2": "if - else and between",
    "data2": "The if, else statement in Java is pretty simple.\n\nif (a == b) {\n    // a and b are equal, let's do something cool\n}\nAnd we can also add an else statement after an if, to do something if the condition is not true\n\nif (a == b) {\n    // We already know this part\n} else {\n    // a and b are not equal... :/\n}\nThe if - else statements doesn't have to be in several lines with {}, if can be used in one line, or without the {}, for a single line statment.\n\nif (a == b)\n    System.out.println(\"Another line Wow!\");\nelse\n    System.out.println(\"Double rainbow!\");\nAlthough this method might be useful for making your code shorter by using fewer lines, we strongly recommend for beginners not to use this short version of statements and to always use the full version with {}. This goes to every statement that can be shorted to a single line (for, while, etc).\n\nThe ugly side of if\nThere is a another way to write a one line if - else statement by using the operator ? :\n\nint a = 4;\nint result = a == 4 ? 1 : 8;\n\n// result will be 1\n// This is equivalent to\nint result;\n\nif (a == 4) {\n    result = 1;\n} else {\n    result = 8;\n}\nAgain, we strongly recommend for beginners not to use this version of if.",
    "subtype3": "== and equals",
    "data3": "The operator == works a bit different on objects than on primitives. When we are using objects and want to check if they are equal, the operator == will say if they are the same, if you want to check if they are logically equal, you should use the equals method on the object. For example:\n\nString a = new String(\"Wow\");\nString b = new String(\"Wow\");\nString sameA = a;\n\nboolean r1 = a == b;      // This is false, since a and b are not the same object\nboolean r2 = a.equals(b); // This is true, since a and b are logically equals\nboolean r3 = a == sameA;  // This is true, since a and sameA are really the same object",
    "subtype4": "Exercise and Solution",
    "data4": "Exercise:\n\nChange the variables in the first section, so that each if statement resolves as true.\n\npublic class Main {\n    public static void main(String[] args) {\n        String a = new String(\"Wow\");\n        String b = \"Wow\";\n        String c = a;\n        String d = c;\n\n        boolean b1 = a == b;\n        boolean b2 = d.equals(b + \"!\");\n        boolean b3 = !c.equals(a);\n\n        if (b1 && b2 && b3) {\n            System.out.println(\"Success!\");\n        }\n    }\n}\n\nSolution:\n\npublic class Main {\n    public static void main(String[] args) {\n        String a = \"Wow\";\n        String b = a;\n        String c = b + \"!\";\n        String d = c;\n\n        boolean b1 = a == b;\n        boolean b2 = d.equals(b + \"!\");\n        boolean b3 = !c.equals(a);\n\n        if (b1 && b2 && b3) {\n            System.out.println(\"Success!\");\n        }\n    }\n}"
  },
  {
    "title": "Arrays",
    "data": "Arrays in Java are also objects. They need to be declared and then created. In order to declare a variable that will hold an array of integers, we use the following syntax:\n\nint[] arr;\nNotice there is no size, since we didn't create the array yet.\n\narr = new int[10];\nThis will create a new array with the size of 10. We can check the size by printing the array's length:\n\nSystem.out.println(arr.length);\nWe can access the array and set values:\n\narr[0] = 4;\narr[1] = arr[0] + 5;\nJava arrays are 0 based, which means the first element in an array is accessed at index 0 (e.g: arr[0], which accesses the first element). Also, as an example, an array of size 5 will only go up to index 4 due to it being 0 based.\n\nint[] arr = new int[5];\n//accesses and sets the first element\narr[0] = 4;\nWe can also create an array with values in the same line:\n\nint[] arr = {1, 2, 3, 4, 5};\nDon't try to print the array without a loop, it will print something nasty like [I@f7e6a96. To print out an array, use the following code:\n\nfor (int i=0; i < arr.length; i++) {\n    System.out.println(arr[i]);\n}",
    "subtype1": "Exercise",
    "data1":"Change the values in numbers so it will not raise an error.\n\npublic class Main {\n    public static void main(String[] args) {\n        int[] numbers = {1, 2, 3};\n        int length = numbers[3];\n        char[] chars = new char[length];\n        chars[numbers.length + 4] = 'y';\n        System.out.println(\"Done!\");\n    }\n}",
    "subtype2": "Solution",
    "data2": "public class Main {\n    public static void main(String[] args) {\n        int[] numbers = {1, 2, 3};\n        int length = numbers[2];\n        char[] chars = new char[length];\n        chars[numbers.length-1] = 'y';\n        System.out.println(\"Done!\");\n    }\n}",
    "subtype3": "",
    "data3": "",
    "subtype4": "",
    "data4": ""
  },
  {
    "title": "Loops",
    "data": "There are two kind of loops in Java, for and while.break and continue\nThese two keywords help us control the loop from within it. break will cause the loop to stop and will go immediately to the next statement after the loop:\n\nint i;\nfor (i = 0; i < 5; i++) {\n    if (i >= 2) {\n        break;\n    }\n    System.out.println(\"Yuhu\");\n}\nSystem.out.println(i);\n// Output:\n// Yuhu\n// Yuhu\n// 2\ncontinue will stop the current iteration and will move to the next one. Notice that inside a for loop, it will still run the third section.\n\nint i;\nfor (i = 0; i < 5; i++) {\n    if (i >= 3) {\n        break;\n    }\n    System.out.println(\"Yuhu\");\n    if (i >= 1) {\n        continue;\n    }\n    System.out.println(\"Tata\");\n}\nSystem.out.println(i);\n// Output\n// Yuhu\n// Tata\n// Yuhu\n// Yuhu\n// 3",
    "subtype1": "For",
    "data1":"The for loop has three sections:\n\nfor (int i = 0; i < 3; i++) {}\nFirst section runs once when we enter the loop.\n\nSecond section is the gate keeper, if it returns true, we run the statements in the loop, if it returns false, we exit the loop. It runs right after the first section for the first time, then every time the loop is finished and the third section is run.\n\nThe third section is the final statement that will run every time the loop runs.\n\nSo in the case we have just seen, the loop will run 3 times. Here is the order of the commands:\n\nint i = 0;\ni < 3 // 0 < 3 = true\n      // Inside of loop\ni++ // i is now 1\ni < 3 // 1 < 3 = true\n      // Inside of loop\ni++ // i is now 2\ni < 3 // 2 < 3 = true\n      // Inside of loop\ni++ // i is now 3\ni < 3 // 3 < 3 = false\n      // Loop is done...\nWe can omit the first and third section of the loop (although it will be weird), and the loop will still work:\n\nfor (;i < 5;) {}\nFor cases where we want to use a loop that look like that, we use a while loop",
    "subtype2": "While",
    "data2": "The syntax is very similar to the previous for we looked at:\n\nwhile (condition) {}\nThe condition will run for the first time when entering and every time the loop is done. If it returns false, the loop will not run.\n\nIf we want the loop to always run at least one, we can use do-while\n\ndo {\n\n} while(condition);\nNotice the ; in the end of the do-while.",
    "subtype3": "Foreach",
    "data3": "Another version of for, is the foreach. The keyword we use is still for, but when we want to iterate on the elements inside an array we can simply use it:\n\nint[] arr = {2, 0, 1, 3};\nfor (int el : arr) {\n    System.out.println(el);\n}\nThis is a short version and equivalent to:\n\nint[] arr = {1, 9, 9, 5};\nfor (int i = 0; i < arr.length; i++) {\n    int el = arr[i];\n    System.out.println(el);\n}\nNotice that if you want to use the index of the element inside the loop, you have to use the longer version and can't use foreach.",
    "subtype4": "Exercise and Solution",
    "data4": "Exercise\nLoop through and print out all even numbers, each in a separate line, from the numbers list in the same order they are received. Don't print any numbers that come after 237 in the sequence.\n\nExercise\nLoop through and print out all even numbers, each in a separate line, from the numbers list in the same order they are received. Don't print any numbers that come after 237 in the sequence.\n\nSolution\n\npublic class Main {\n    public static void main(String[] args) {\n        int[] numbers = {\n            951, 402, 984, 651, 360, 69, 408, 319, 601, 485, 980, 507, 725, 547, 544, \n            615, 83, 165, 141, 501, 263, 617, 865, 575, 219, 390, 984, 592, 236, 105, 942, 941, \n            386, 462, 47, 418, 907, 344, 236, 375, 823, 566, 597, 978, 328, 615, 953, 345, \n            399, 162, 758, 219, 918, 237, 412, 566, 826, 248, 866, 950, 626, 949, 687, 217, \n            815, 67, 104, 58, 512, 24, 892, 894, 767, 553, 81, 379, 843, 831, 445, 742, 717, \n            958, 609, 842, 451, 688, 753, 854, 685, 93, 857, 440, 380, 126, 721, 328, 753, 470, \n            743, 527};\n        \n        for (int i = 0; i < numbers.length; i++) {\n            int el = numbers[i];\n\n            if (el == 237) {\n                break;\n            }\n\n            // using the division remainder operator %\n            if (el % 2 == 0) {\n                System.out.println(el);\n            }\n\n        }\n    }\n}"
  },
  {
    "title": "Functions",
    "data": "In Java, all function definitions must be inside classes. We also call functions methods. Let's look at an example method\n\npublic class Main {\n    public static void foo() {\n        // Do something here\n    }\n}\nfoo is a method we defined in class Main. Notice a few things about foo.\n\nstatic means this method belongs to the class Main and not to a specific instance of Main. Which means we can call the method from a different class like that Main.foo().\nvoid means this method doesn't return a value. Methods can return a single value in Java and it has to be defined in the method declaration. However, you can use return by itself to exit the method.\nThis method doesn't get any arguments, but of course Java methods can get arguments as we'll see further on.",
    "subtype1": "Arguments",
    "data1":"I always like to say that arguments to Java methods are passed by value, although some might disagree with my choice of words, I find it the best way to explain and understand how it works exactly.\n\nBy value means that arguments are copied when the method runs. Let's look at an example.\n\npublic void bar(int num1, int num2) {\n    ...\n}\nHere is a another place in the code, where bar is called\n\nint a = 3;\nint b = 5;\nbar(a, b);\nYou can picture in your head that when bar(a, b) is run, it's like in the beginning of bar the following two lines are written:\n\nint num1 = a;\nint num2 = b;\nAnd only then the rest of the method is run.\n\nThis means that a value get copied to num1 and b value get copied to num2. Changing the values of num1 and num2 will not affect a and b.\n\nIf the arguments were objects, the rules remain the same, but it acts a bit differently. Here is a an example:\n\npublic void bar2(Student s1, Student s2) {\n    ...\n}\nAnd here is how we use it\n\nStudent joe = new Student(\"joe\");\nStudent jack = new Student(\"jack\");\nbar2(joe, jack);\nAgain we can picture the same two lines in the beginning of bar2\n\nStudent s1 = joe;\nStudent s2 = jack;\nBut when we assign objects, it's a bit different than assigning primitives. s1 and joe are two different references to the same object. s1 == joe is true. This means that running methods on s1 will change the object joe. But if we'll change the value of s1 as a reference, it will not affect the reference joe.\n\ns1.setName(\"Chuck\"); // joe name is now Chuck as well\ns1 = new Student(\"Norris\"); // s1 is a new student, different than joe with the name of Norris\n// s1 == joe   is not true anymore",
    "subtype2": "Non static methods",
    "data2": "Non static methods in Java are used more than static methods. Those methods can only be run on objects and not on the whole class.\n\nNon static methods can access and alter the field of the object.\n\npublic class Student {\n    private String name;\n    public String getName() {\n        return name;\n    }\n    public void setName(String name) {\n        this.name = name;\n    }\n}\nCalling the methods will require an object of type Student.\n\nStudent s = new Student();\ns.setName(\"Danielle\");\nString name = s.getName();\n\nStudent.setName(\"Bob\"); // Will not work!\nStudent.getName(); // Will not work!\nSummary\nEvery Java method has to be within a class\nStatic methods belong to a class while non-static methods belong to objects\nAll parameters to functions are passed by value, primitives content is copied, while objects are not copied and some would say 'passed by reference'",
    "subtype3": "Exercise",
    "data3": "Write the method printFullName of student which prints the full name of a student.\n\nclass Student {\n    private String firstName;\n    private String lastName;\n    public Student(String firstName, String lastName) {\n        this.firstName = firstName;\n        this.lastName = lastName;\n    }\n    // Your code goes here\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Student[] students = new Student[] {\n            new Student(\"Morgan\", \"Freeman\"),\n            new Student(\"Brad\", \"Pitt\"),\n            new Student(\"Kevin\", \"Spacey\"),\n        };\n        for (Student s : students) {\n            s.printFullName();\n        }\n    }\n}",
    "subtype4": "Solution",
    "data4": "class Student {\n    private String firstName;\n    private String lastName;\n    public Student(String firstName, String lastName) {\n        this.firstName = firstName;\n        this.lastName = lastName;\n    }\n    \n    public void printFullName() {\n        System.out.println (this.firstName+\" \"+this.lastName);\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Student[] students = new Student[] {\n            new Student(\"Morgan\", \"Freeman\"),\n            new Student(\"Brad\", \"Pitt\"),\n            new Student(\"Kevin\", \"Spacey\"),\n        };\n        for (Student s : students) {\n            s.printFullName();\n        }\n    }\n}"
  },
  {
    "title": "Compiling and Running with Arguments",
    "data": "This section is used for you to use Java at home and understand the basics of how things are done.\n\nAfter creating a simple application that prints something to the screen, you need to compile your code and run it.\n\nIt shouldn't really matter if you use Linux, Mac or Windows. You need to have a console and you need to have the following commands available in order to compile and run Java.\n\njava (or java.exe)\njavac (or javac.exe)\nIn order for those to be available you must download and install JDK (Java Development Kit).\n\nIf we take the code from the previous lesson and put it in a file called MyFirstClass.java, in order to compile it we need to run:\n\njavac MyFirstClass.java\nThis will create a file called MyFirstClass.class that holds the compiled java code.\n\nTo run it, we need to run java with the name of the class as the argument (Not the file!)\n\nWrong\njava MyFirstClass.class\nRight!\njava MyFirstClass",
    "subtype1": "Arguments",
    "data1":"The main methods get an array of strings as an argument, these are the command line arguments you may pass to your program.\n\nEvery array in java holds a variable called length that says how many elements are within that array.\n\nWe can go over the arguments with a simple for\n\npublic class Arguments {\n    public static void main(String[] args) {\n        for (int i = 0; i < args.length; i++) {\n            System.out.println(args[i]);\n        }\n    }\n}\nAnd to compile and run it with arguments:\n\njavac Arguments.java\njava Arguments arg0 arg1 arg2",
    "subtype2": "Exercise",
    "data2": "Create a program that prints the arguments of our program. Write one argument per line.",
    "subtype3": "Solution",
    "data3": "public class Main {\n    public static void main(String[] args) {\n        // write your code here\n\tfor (int i=0; i<args.length; i++)\n    {\n     System.out.println(args[i]);   \n    }\n    }\n}",
    "subtype4": "",
    "data4": ""
  },
  {
    "title": "Inheritance",
    "data": "In Java, the term inheritance refers to the adoption of all non-private properties and methods of one class (superclass) by another class (subclass). Inheritance is a way to make a copy of an existing class as the starting point for another. In addition to the term subclass, inherited classes are also called derived classes.\n\nAt this point, it may be helpful to distinguish inheritance from interfaces. Interfaces define only the structure of the class members while inherited classes include the actual code of the superclass. Additionally, inheritance (more accurately, the definition of a subclass) uses the extends keyword in the subclass declaration.\n\nFor clarity, if a subclass is created using a superclass and the subclass remains unaltered, the two classes will be identical. But most subclasses do not remain unaltered. Because a subclass is still a class, it can be altered to include new properties and methods. The finished subclass can even be used as a superclass to create additional subclasses. There is no effective limit to the number of inheritance levels.\n\nThe methods and properties of a subclass can be used just like those of it's superclass. They can also be overridden. Overriding is the process of replacing (or augmenting) the original code with new code to suit the current purpose. An overridden method's signature in the subclass remains the same as the superclass but the contents of the method will be changed to meet the goal of the method in it's new form. This may even mean executing the code inherited from the superclass before or after executing some new code within the same method. To execute the inherited code from within the subclass, prefix the method with super. It is also possible to write a subclass constructor that invokes the constructor of the superclass, either implicitly or by using the super keyword (e.g., super.methodName()).\n\nWhy do this? Inheritance promotes code reuse and the concept of generic-to-specific implementation. Ideally, a superclass will be written at the most generic level. Subclasses can then be created from the superclass with a finer, more specific purpose.",
    "subtype1": "An example of inheritence",
    "data1":"Think of a door. It doesn't matter what kind. All doors open and close. However, some doors open differently than others (lifting up vs swinging out, swinging in vs sliding across). So, let's say Door is the superclass for a door and it has an open method. The method is simple. It's only instruction is push.\n\npublic class Door {\n    public void open ()\n    {\n        push();     // Since this is just a generic \"Door\" we will assume the simplest opening method.\n                    // The actual open method must be overridden by a subclass, as we see below.\n                    // Later, a way to force a subclass to override a method will be demonstrated -- \n                    // but for this simple example will do for now.\n    }\n}\nUsing this class on a bank vault door might prove unsuccessful. A better strategy would be to \"subclass\" Door using inheritance and then override the open method to input the combination and pull rather than push.\n\nclass BankVaultDoor extends Door {    // The \"extends\" keyword used to tell java that BankVaultDoor inherits the functionality of Door.\n\n    public void open () {\n        enterCombination();\n        pull;\n    }\n\n}\nThe advantage of using inheritance is writing code that applies to a number of classes that extend a more general class. In the below example we have a method that opens several types of doors.\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Door d1 = new BankVaultDoor();\n        Door d2 = new HouseFrontDoor();\n        Door d3 = new CarDoor();\n    }\n\n    if (arg[0] == \"car\") {\n        d3.open();\n    } else if (arg[0] == \"bank\") {\n        d1.open();\n    } else {\n        d2.open();\n    }\n}\nNotice that the open() method doesn't know (or care) about the type of door. Any class that is subclassed from Door (using extends Door) will use the open() method to open it.\n\n",
    "subtype2": "Exercise",
    "data2": "Create a house front door class which inherits from the Door class and open it. Assume the house door has a locked doorknob and it swings into the house. Hint: Your code should use the super keyword.\n\n public class Door {\n        public void open ()\n        {\n            push();\n        }\n    }\n\n    class BankVaultDoor extends Door {\n  \n        public void open () {\n            enterCombination();\n            pull;\n        }\n  \n    }\n\n    class HouseFrontDoor extends Door {\n        // Your code goes here\n    }",
    "subtype3": "Solution",
    "data3": "public class Door {\n        public void open ()\n        {\n            push();\n        }\n    }\n\n    class BankVaultDoor extends Door {\n  \n        public void open () {\n            enterCombination();\n            pull;\n        }\n  \n    }\n\n    class HouseFrontDoor extends Door {\n\n        public void open () {\n            insertKeyAndTurnKnob();\n            super.push();\n        }\n\n    }",
    "subtype4": "",
    "data4": ""
  },

  {
    "title": "Try and Catch",
    "data": "Before going into try/catch statements, let's talk about Exceptions. Exceptions are thrown every time an error occurs. Some examples: ArrayIndexOutOfBounds is thrown if the index that does not exist in an array is accessed (e.g: Trying to access arr[5], but arr only goes up to arr[4]) ArithmeticError is thrown if an illegal arithmetic operation is done (e.g: 42/0, division by zero)\n\nThere are lots of exceptions that Java can throw (more than the above).\n\nBut, how can you handle exceptions, when you're unsure if an error will occur.\n\nThat's the purpose of try/catch! This is the syntax for try/catch:\n\n  try {\n    //Code here\n  } catch (ExceptionHere name) {\n        //Replace ExceptionHere with your exception and name with the name of your exception.\n        //Code if exception \"ExceptionHere\" is thrown.\n  }\nThe code after the try block will be attempted to be run. If the exception in the catch statement is thrown during the code in the try block is run, run the code in the catch block.\n\nYou can tell the user that there is a problem, or anything else.\n\nNOTE: You can also use Exception as the exception to catch if any exception is thrown.",
    "subtype1": "Exercise",
    "data1":"In this exercise, you will try to catch problematic code. I will create a problematic code block. I want you to wrap the problematic code in the try block, than make it print \"Problem with code detected\" if the exception is thrown.\n\nNOTE: Use ArrayIndexOutOfBoundsException as exception, or Exception as the exception.\n\npublic class Main {\n    public static void main(String[] args) {\n        int[] arr = new int[10];\n        System.out.println(arr[9001]);\n    }\n}",
    "subtype2": "Solution",
    "data2": "public class Main {\n    public static void main(String[] args) {\n        int[] arr = new int[10];\n        try {\n            System.out.println(arr[9001]);\n        } catch (ArrayIndexOutOfBoundsException ex) {\n            System.out.println(\"Problem with code detected\");\n        }\n    }\n}",
    "subtype3": "",
    "data3": "",
    "subtype4": "",
    "data4": ""
  },
  {
    "title": "Abstract Classes",
    "data": "An Abstract class is a class which has abstract keyword prefixed to it. A class must be prefixed with abstract if it has one or more methods with abstract keyword. An abstract method is only declared but not implemented. An abstract class cannot be instanciated but can be inherited by another class. The inheriting class must implement all the abstract methods or else the subclass should also be declared as abstract.\n\nFor example:\n\nabstract class abstractClass { \n    abstract void abstractMethod(); \n    void concreteMethod() { // concrete methods are still allowed in abstract classes \n        System.out.println(\"This is a concrete method.\"); \n    } \n}",
    "subtype1": "Abstract classes versus interface",
    "data1":"Abstract classes can contain fields which are not final and static and can contain implemented methods as well but interfaces cannot. Abstract classes with only abstract methods should be defined as interfaces.\n\nWhen an abstract class implements an interface not all interface methods need to be implemented, if the class is not abstract all the interface methods should be implemented.\n\nFor example:\n\nabstract class X implements Y {\n// implements all but one method of Y\n}\n\nclass XX extends X {\n// implements the remaining method in Y\n}\nAbstract classes can have static fields and static methods and works it would with normal classes.",
    "subtype2": "Exercise",
    "data2": "Create a subclass of the abstract class and implement the abstract method.\n\nabstract class abstractClass { \n    abstract void abstractMethod(); \n    void concreteMethod() { // concrete methods are still allowed in abstract classes \n        System.out.println(\"This is a concrete method.\"); \n    } \n}\n\nclass B extends abstractClass { \n    void abstractMethod() { \n        System.out.println(\"B's implementation of abstractMethod.\"); \n    } \n}\n\nclass C extends abstractClass { \n    // Your code goes here\n}\n\npublic class Main { \n    public static void main(String args[]) { \n        B b = new B(); \n        b.abstractMethod(); \n        b.concreteMethod();\n        C c = new C(); \n        c.abstractMethod(); \n        c.concreteMethod();\n    } \n}",
    "subtype3": "Solution",
    "data3": "abstract class abstractClass { \n    abstract void abstractMethod(); \n    void concreteMethod() { // concrete methods are still allowed in abstract classes \n        System.out.println(\"This is a concrete method.\"); \n    } \n}\n\nclass B extends abstractClass { \n    void abstractMethod() { \n        System.out.println(\"B's implementation of abstractMethod.\"); \n    } \n}\n\nclass C extends abstractClass { \n    void abstractMethod() { \n        System.out.println(\"C's implementation of abstractMethod.\"); \n    } \n}\n\npublic class Main { \n    public static void main(String args[]) { \n        B b = new B(); \n        b.abstractMethod(); \n        b.concreteMethod();\n        C c = new C(); \n        c.abstractMethod(); \n        c.concreteMethod();\n    } \n}",
    "subtype4": "",
    "data4": ""
  },
  {
    "title": "Interfaces",
    "data": "Interfaces are class templates. Although not strictly required, they are part of the organizational structure of object-oriented programming. Interfaces define methods for classes by specifying the method name, the return type (or void) and the method arguments (by type and name). These method definitions are called signatures. Because this is a template, the method signatures contain no code. The code is entered into the implementation of an interface. Interfaces are used in the discipline of polymorphism.\n\nNote these two important points about interfaces:\n\nIf a class implements an interface, all of the interface's methods must appear in the class.\nThe implements keyword is used when creating a class that is modeled after an interface.",
    "subtype1": "An analogy",
    "data1":"Think of cutting a duck decoy from a block of wood. First, a template is used to trace the pattern onto the wood. Then, when the wood is cut, it resembles the template. At this point, however, neither the template nor the wood have any of the fine details that one would expect from a finished decoy. The template was used to define basic characteristics, not precise details. After multiple duck-shaped pieces have been cut, each one can be carved and decorated uniquely. Yet, they all have the same basic size and shape.\n\nAn interface is generally used as a template for multiple classes. These classes all share the methods defined in the interface. However, the implementation of the methods may vary from one class to another.",
    "subtype2": "An example of an interface",
    "data2": "An interface named Animal might have method defintions for feed, groom and pet. The feeding, grooming and petting of animals can be as different as the animals themselves.\n\ninterface Animal {\n    bool feed(bool timeToEat);\n    void groom();\n    void pet();\n}\nA dog class, for instance, may be implemented in a somewhat predictable way.\n\nclass Dog implements Animal {\n    bool feed(bool timeToEat) {\n      // pour food into bowl\n      return true;\n    }\n    void groom() {\n      // brush well\n    }\n    void pet() {\n      // pet cautiously\n    }\n}\nOther animal classes, may have specific needs.\n\nclass Giraffe implements Animal {\n    bool feed(bool timeToEat) {\n      // point to the trees \n      return true;\n    }\n    void groom() {\n      // get a ladder\n      // brush well\n    }\n    void pet() {\n      // get a ladder\n      // pet cautiously\n    }\n}\n\nclass Tiger implements Animal {\n    bool feed(bool timeToEat) {\n      // toss raw meat into cage\n      return true\n    }\n    void groom() {\n      // tranquilize\n      // brush well\n    }\n    void pet() {\n      // DO NOT PET\n    }\n}",
    "subtype3": "Exercise",
    "data3": "Create a gorilla class which implements the Animal interface.\n\ninterface Animal {\n    bool feed(bool timeToEat);\n    void groom();\n    void pet();\n}",
    "subtype4": "Solution",
    "data4": "class Gorilla implements Animal {\n    bool feed(bool timeToEat) {\n      // put gorilla food into cage\n      return true;\n    }\n    void groom() {\n      // lather, rinse, repeat\n    }\n    void pet() {\n      // pet at your own risk\n    }\n}  "
  },
  {
    "title": "Generics",
    "data": "Generics provide compile-time type safety that allows programmers to catch invalid types at compile time.\n\nAs this feature is often used with collections, we will focus on collections. Generics allows the user to set the type of the collection to limit what kind of objects can be inserted into the collection. The user also does not have to cast the values obtain from the collection.\n\nWhen declaring a generic, it must have a type parameter specifying what type of elements will be in the collection. For example, to declare a list containing strings, you would write:\n\nList<String> names = new ArrayList<>();",
    "subtype1": "Generics in class declaration",
    "data1":"You can also use generics for class definition:\n\npublic class YourClass<Class1,Class2>{\n    private Class1 bob1;\n    private Class2 bob2;\n    Abc(Class1 a, Class2 b){\n        this.bob1 = a;\n        this.bob2 = b;\n    }\n    public Class1 getBob1() {\n        return (this.bob1);\n    }\n    public Class2 getBob2() {\n        return (this.bob2);\n    }\n}\nThis is usefull when you want to have multiple options for classes of variables in your class, but don't want to write new constructors and functions for every single type. Now you can just run:\n\nYourClass<String, Integer> leBobs = new YourClass<>(\"words\",42);  //in this case, <> is the same as putting <String, Integer>\nString a=leBobs.getBob1();\nint b=leBobs.getBob2();\nSystem.out.println(\"bob1 is '\" + a + \"', and bob2 is '\" + b + \"'.\");\nTo change the types of bob1 and bob2 just change the classes in the <> when you declare an object of the class YourClass.\n\nNote: you cannot use primitives for generics unless you use their class version: ie <~~int~~ Integer> or <~~bool~~ Boolean>",
    "subtype2": "Exercise",
    "data2": "Fix the FavoriteClasses class to use generics for it's three variables, favorite1, favorite2, and favorite3, it's constructor, and it's three functions to return each variable, as well as fixing r in the main section.\nThen define a variable of the FavoriteClasses class and use \"Hello\", 67, 6.3 as the arguments for the constructor, and when you define it use your favorite classes/types that go with the three arguments.\n\nimport java.util.*;\npublic class Main{\n    public static class FavoriteClasses{\n        private favorite1;\n        private favorite2;\n        private favorite3;\n        FavoriteClasses(fav1, fav2, fav3){\n            this.favorite1=fav1;\n            this.favorite2=fav2;\n            this.favorite3=fav3;\n        }\n        public getFav1(){\n            return(this.favorite1);\n        }\n        public getFav2(){\n            return(this.favorite2);\n        }\n        public getFav3(){\n            return(this.favorite3);\n        }\n    }\n    public static main(String[] args){\n        List r=new ArrayList();\n        r.add(6.3);\n        r.add(5.9);\n        FavoriteClasses a=new FavoriteClasses(\"Hello\",67,r.get(0));\n        System.out.println(\"My favorites are \" + a.getFav1() + \", \" a.getFav2() + \", and \" + a.getFav3() + \".\");\n    }\n}",
    "subtype3": "Solution",
    "data3": "import java.util.*;\npublic class Main{\n    public static class FavoriteClasses<ClassA,ClassB,ClassC>{\n        private ClassA favorite1;\n        private ClassB favorite2;\n        private ClassC favorite3;\n        FavoriteClasses(ClassA fav1, ClassB fav2, ClassC fav3){\n            this.favorite1=fav1;\n            this.favorite2=fav2;\n            this.favorite3=fav3;\n        }\n        public ClassA getFav1(){\n            return(this.favorite1);\n        }\n        public ClassB getFav2(){\n            return(this.favorite2);\n        }\n        public ClassC getFav3(){\n            return(this.favorite3);\n        }\n    }\n    public static main(String[] args){\n        List<Float> r=new ArrayList<>();     //can also be double or any other that supports decimals\n        r.add(6.3);\n        r.add(5.9);\n        FavoriteClasses<String, Integer, Float> a=new FavoriteClasses<>(\"Hello\",67,r.get(0)); //same with int\n        System.out.println(\"My favorites are \" + a.getFav1() + \", \" a.getFav2() + \", and \" + a.getFav3() + \".\");\n    }\n}",
    "subtype4": "",
    "data4": ""
  },{
  "title": "Collections",
  "data": "",
  "subtype1": "",
  "data1":"",
  "subtype2": "",
  "data2": "",
  "subtype3": "",
  "data3": "",
  "subtype4": "",
  "data4": ""
},
  {
    "title": "Java File Handling",
    "data": "The File class from the java.io package, allows us to work with files.\n\nTo use the File class, create an object of the class, and specify the filename or directory name:\n\nExample\nimport java.io.File;  // Import the File class\n\nFile myObj = new File(\"filename.txt\"); // Specify the filename\nIf you don't know what a package is, read our Java Packages Tutorial.\n\nThe File class has many useful methods for creating and getting information about files. For example:\n\nMethod\tType\tDescription\ncanRead()\tBoolean\tTests whether the file is readable or not\ncanWrite()\tBoolean\tTests whether the file is writable or not\ncreateNewFile()\tBoolean\tCreates an empty file\ndelete()\tBoolean\tDeletes a file\nexists()\tBoolean\tTests whether the file exists\ngetName()\tString\tReturns the name of the file\ngetAbsolutePath()\tString\tReturns the absolute pathname of the file\nlength()\tLong\tReturns the size of the file in bytes\nlist()\tString[]\tReturns an array of the files in the directory\nmkdir()\tBoolean\tCreates a directory\n",
    "subtype1": "Create a File",
    "data1":"To create a file in Java, you can use the createNewFile() method. This method returns a boolean value: true if the file was successfully created, and false if the file already exists. Note that the method is enclosed in a try...catch block. This is necessary because it throws an IOException if an error occurs (if the file cannot be created for some reason):\n\nExample\nimport java.io.File;  // Import the File class\nimport java.io.IOException;  // Import the IOException class to handle errors\n\npublic class CreateFile {\n  public static void main(String[] args) {\n    try {\n      File myObj = new File(\"filename.txt\");\n      if (myObj.createNewFile()) {\n        System.out.println(\"File created: \" + myObj.getName());\n      } else {\n        System.out.println(\"File already exists.\");\n      }\n    } catch (IOException e) {\n      System.out.println(\"An error occurred.\");\n      e.printStackTrace();\n    }\n  }\n}\nThe output will be:\n\nFile created: filename.txt\nTo create a file in a specific directory (requires permission), specify the path of the file and use double backslashes to escape the \"\\\" character (for Windows). On Mac and Linux you can just write the path, like: /Users/name/filename.txt\n\nExample\nFile myObj = new File(\"C:\\\\Users\\\\MyName\\\\filename.txt\");",
    "subtype2": "Write To a File",
    "data2": "In the following example, we use the FileWriter class together with its write() method to write some text to the file we created in the example above. Note that when you are done writing to the file, you should close it with the close() method:\n\nExample\nimport java.io.FileWriter;   // Import the FileWriter class\nimport java.io.IOException;  // Import the IOException class to handle errors\n\npublic class WriteToFile {\n  public static void main(String[] args) {\n    try {\n      FileWriter myWriter = new FileWriter(\"filename.txt\");\n      myWriter.write(\"Files in Java might be tricky, but it is fun enough!\");\n      myWriter.close();\n      System.out.println(\"Successfully wrote to the file.\");\n    } catch (IOException e) {\n      System.out.println(\"An error occurred.\");\n      e.printStackTrace();\n    }\n  }\n}\nThe output will be:\n\nSuccessfully wrote to the file.",
    "subtype3": "Read a File",
    "data3": "In the following example, we use the Scanner class to read the contents of the text file we created in the previous chapter:\n\nExample\nimport java.io.File;  // Import the File class\nimport java.io.FileNotFoundException;  // Import this class to handle errors\nimport java.util.Scanner; // Import the Scanner class to read text files\n\npublic class ReadFile {\n  public static void main(String[] args) {\n    try {\n      File myObj = new File(\"filename.txt\");\n      Scanner myReader = new Scanner(myObj);\n      while (myReader.hasNextLine()) {\n        String data = myReader.nextLine();\n        System.out.println(data);\n      }\n      myReader.close();\n    } catch (FileNotFoundException e) {\n      System.out.println(\"An error occurred.\");\n      e.printStackTrace();\n    }\n  }\n}\nThe output will be:\n\nFiles in Java might be tricky, but it is fun enough!\n\nGet File Information\nTo get more information about a file, use any of the File methods:\n\nExample\nimport java.io.File;  // Import the File class\n\npublic class GetFileInfo { \n  public static void main(String[] args) {\n    File myObj = new File(\"filename.txt\");\n    if (myObj.exists()) {\n      System.out.println(\"File name: \" + myObj.getName());\n      System.out.println(\"Absolute path: \" + myObj.getAbsolutePath());\n      System.out.println(\"Writeable: \" + myObj.canWrite());\n      System.out.println(\"Readable \" + myObj.canRead());\n      System.out.println(\"File size in bytes \" + myObj.length());\n    } else {\n      System.out.println(\"The file does not exist.\");\n    }\n  }\n}\nThe output will be:\n\nFile name: filename.txt\nAbsolute path: C:\\Users\\MyName\\filename.txt\nWriteable: true\nReadable: true\nFile size in bytes: 0",
    "subtype4": "Delete a File or Folder",
    "data4": "To delete a file in Java, use the delete() method:\n\nExample\nimport java.io.File;  // Import the File class\n\npublic class DeleteFile {\n  public static void main(String[] args) { \n    File myObj = new File(\"filename.txt\"); \n    if (myObj.delete()) { \n      System.out.println(\"Deleted the file: \" + myObj.getName());\n    } else {\n      System.out.println(\"Failed to delete the file.\");\n    } \n  } \n}\nThe output will be:\n\nDeleted the file: filename.txt\n\n\nYou can also delete a folder. However, it must be empty:\n\nExample\nimport java.io.File; \n\npublic class DeleteFolder {\n  public static void main(String[] args) { \n    File myObj = new File(\"C:\\\\Users\\\\MyName\\\\Test\"); \n    if (myObj.delete()) { \n      System.out.println(\"Deleted the folder: \" + myObj.getName());\n    } else {\n      System.out.println(\"Failed to delete the folder.\");\n    } \n  } \n}\nThe output will be:\n\nDeleted the folder: Test"
  },
  {
    "title": "Java Threads",
    "data": "Threads allows a program to operate more efficiently by doing multiple things at the same time.\n\nThreads can be used to perform complicated tasks in the background without interrupting the main program.",
    "subtype1": "Creating a Thread",
    "data1":"There are two ways to create a thread.\n\nIt can be created by extending the Thread class and overriding its run() method:\n\nExtend Syntax\npublic class MyClass extends Thread {\n  public void run() {\n    System.out.println(\"This code is running in a thread\");\n  }\n}\nAnother way to create a thread is to implement the Runnable interface:\n\nImplement Syntax\npublic class MyClass implements Runnable {\n  public void run() {\n    System.out.println(\"This code is running in a thread\");\n  }\n}",
    "subtype2": "Running Threads",
    "data2": "If the class extends the Thread class, the thread can be run by creating an instance of the class and call its start() method:\n\nExtend Example\npublic class MyClass extends Thread {\n  public static void main(String[] args) {\n    MyClass thread = new MyClass();\n    thread.start();\n    System.out.println(\"This code is outside of the thread\");\n  }\n  public void run() {\n    System.out.println(\"This code is running in a thread\");\n  }\n}\n\nIf the class implements the Runnable interface, the thread can be run by passing an instance of the class to a Thread object's constructor and then calling the thread's start() method:\n\nImplement Example\npublic class MyClass implements Runnable {\n  public static void main(String[] args) {\n    MyClass obj = new MyClass();\n    Thread thread = new Thread(obj);\n    thread.start();\n    System.out.println(\"This code is outside of the thread\");\n  }\n  public void run() {\n    System.out.println(\"This code is running in a thread\");\n  }\n}",
    "subtype3": "Differences between \"extending\" and \"implementing\" Threads",
    "data3": "The major difference is that when a class extends the Thread class, you cannot extend any other class, but by implementing the Runnable interface, it is possible to extend from another class as well, like: class MyClass extends OtherClass implements Runnable.",
    "subtype4": "Concurrency Problems",
    "data4": "Because threads run at the same time as other parts of the program, there is no way to know in which order the code will run. When the threads and main program are reading and writing the same variables, the values are unpredictable. The problems that result from this are called concurrency problems.\n\nExample\nA code example where the value of the variable amount is unpredictable:\n\npublic class MyClass extends Thread {\n  public static int amount = 0;\n\n  public static void main(String[] args) {\n    MyClass thread = new MyClass();\n    thread.start();\n    System.out.println(amount);\n    amount++;\n    System.out.println(amount);\n  }\n\n  public void run() {\n    amount++;\n  }\n}\n\nTo avoid concurrency problems, it is best to share as few attributes between threads as possible. If attributes need to be shared, one possible solution is to use the isAlive() method of the thread to check whether the thread has finished running before using any attributes that the thread can change.\n\nExample\nUse isAlive() to prevent concurrency problems:\n\npublic class MyClass extends Thread {\n  public static int amount = 0;\n\n  public static void main(String[] args) {\n    MyClass thread = new MyClass();\n    thread.start();\n    // Wait for the thread to finish\n    while(thread.isAlive()) {\n    System.out.println(\"Waiting...\");\n  }\n  // Update amount and print its value\n  System.out.println(\"Main: \" + amount);\n  amount++;\n  System.out.println(\"Main: \" + amount);\n  }\n  public void run() {\n    amount++;\n  }\n}"
  },
  {
    "title": "Lambda Expressions",
    "data": "Lambda Expressions were added in Java 8.\n\nA lambda expression is a short block of code which takes in parameters and returns a value. Lambda expressions are similar to methods, but they do not need a name and they can be implemented right in the body of a method.\n\n",
    "subtype1": "Syntax",
    "data1":"The simplest lambda expression contains a single parameter and an expression:\n\nparameter -> expression\nTo use more than one parameter, wrap them in parentheses:\n\n(parameter1, parameter2) -> expression\nExpressions are limited. They have to immediately return a value, they cannot contain variables, assignments or statements such as if or for. In order to do more complex operations, a code block can be used with curly braces. If the lambda expression needs to return a value then the code block should have a return statement.\n\n(parameter1, parameter2) -> { code block }",
    "subtype2": "Using Lambda Expressions",
    "data2": "Lambda expressions are usually passed as parameters to a function:\n\nExample\nUse a lamba expression in the ArrayList's forEach() method to print every item in the list:\n\nimport java.util.ArrayList;\n\npublic class MyClass {\n  public static void main(String[] args) {\n    ArrayList<Integer> numbers = new ArrayList<Integer>();\n    numbers.add(5);\n    numbers.add(9);\n    numbers.add(8);\n    numbers.add(1);\n    numbers.forEach( (n) -> { System.out.println(n); } );\n  }\n}\n\nLambda expressions can be stored in variables if the variable's type is an interface which has only one method. The lambda expression should have the same number of parameters and the same return type as that method. Java has many of these kinds of interfaces built in, such as the Consumer interface (found in the java.util package) used by lists.\n\nExample\nUse Java's Consumer interface to store a lambda expression in a variable:\n\nimport java.util.ArrayList;\nimport java.util.function.Consumer;\n\npublic class MyClass {\n  public static void main(String[] args) {\n    ArrayList<Integer> numbers = new ArrayList<Integer>();\n    numbers.add(5);\n    numbers.add(9);\n    numbers.add(8);\n    numbers.add(1);\n    Consumer<Integer> method = (n) -> { System.out.println(n); };\n    numbers.forEach( method );\n  }\n}\n\nTo use a lambda expression in a method, the method should have a parameter with a single-method interface as its type. Calling the interface's method will run the lambda expression:\n\nExample\nCreate a method which takes a lambda expression as a parameter:\n\ninterface StringFunction {\n  String run(String str);\n}\n\npublic class MyClass {\n  public static void main(String[] args) {\n    StringFunction exclaim = (s) -> s + \"!\";\n    StringFunction ask = (s) -> s + \"?\";\n    printFormatted(\"Hello\", exclaim);\n    printFormatted(\"Hello\", ask);\n  }\n  public static void printFormatted(String str, StringFunction format) {\n    String result = format.run(str);\n    System.out.println(result);\n  }\n}",
    "subtype3": "",
    "data3": "",
    "subtype4": "",
    "data4": ""
  }


]